import numpy as np
import jax.numpy as jnp
import jax
import matplotlib.pyplot as plt
from functools import partial


import dubinsEZ

# Vectorized function using vmap
in_dubins_engagement_zone = jax.jit(
    jax.vmap(
        dubinsEZ.in_dubins_engagement_zone_single,
        in_axes=(
            0,
            0,
            0,
            None,
            None,
            0,
            None,
            None,
            None,
        ),  # Vectorizing over evaderPosition & evaderHeading
    )
)

# in_dubins_engagement_zone = jax.jit(
#     jax.vmap(
#         dubinsEZ.in_dubins_engagement_zone_single,
#         in_axes=(
#             None,
#             None,
#             None,
#             None,
#             None,
#             0,
#             None,
#             None,
#             None,
#         ),  # Vectorizing over evaderPosition & evaderHeading
#     )
# )


def mc_dubins_pez_single(
    evaderPosition,
    evaderHeading,
    evaderSpeed,
    pursuerPosition,
    pursuerHeading,
    pursuerSpeed,
    minimumTurnRadius,
    pursuerRange,
    captureRadius,
    numSamples,
):
    ez, goalPositions = in_dubins_engagement_zone(
        pursuerPosition,
        pursuerHeading,
        minimumTurnRadius,
        captureRadius,
        pursuerRange,
        pursuerSpeed,
        evaderPosition,
        evaderHeading,
        evaderSpeed,
    )
    return jnp.sum(ez <= 0) / numSamples, goalPositions, ez, pursuerHeading


mc_dubins_pez = jax.jit(
    jax.vmap(
        mc_dubins_pez_single,
        in_axes=(0, 0, None, None, None, None, None, None, None, None),
    )
)


@jax.jit
def map_angle(angle):
    return (angle + jnp.pi) % (2 * jnp.pi) - jnp.pi


def mc_dubins_PEZ(
    evaderPositions,
    evaderHeadings,
    evaderSpeed,
    pursuerPosition,
    pursuerPositionCov,
    pursuerHeading,
    pursuerHeadingVar,
    pursuerSpeed,
    pursuerSpeedVar,
    minimumTurnRadius,
    minimumTurnRadiusVar,
    pursuerRange,
    pursuerRangeVar,
    captureRadius,
):
    key = jax.random.PRNGKey(121252)

    key, subkey = jax.random.split(key)
    numSamples = 200

    normalSamples = jax.random.normal(subkey, shape=(numSamples,))

    # Generate heading samples
    pursuerHeadingSamples = (
        pursuerHeading + jnp.sqrt(pursuerHeadingVar) * normalSamples
    )  # * jax.random.normal(subkey, shape=(numSamples,))

    # generate turn radius samples
    minimumTurnRadiusSamples = (
        minimumTurnRadius + jnp.sqrt(minimumTurnRadiusVar) * normalSamples
    )  # * jax.random.normal(subkey, shape=(numSamples,))

    # generate speed samples
    pursuerSpeedSamples = (
        pursuerSpeed + jnp.sqrt(pursuerSpeedVar) * normalSamples
    )  # * jax.random.normal(subkey, shape=(numSamples,))

    # generate position samples
    pursuerPositionSamples = jax.random.multivariate_normal(
        key, pursuerPosition, pursuerPositionCov, shape=(numSamples,)
    )

    return mc_dubins_pez(
        evaderPositions,
        evaderHeadings,
        evaderSpeed,
        pursuerPositionSamples,
        pursuerHeadingSamples,
        pursuerSpeedSamples,
        minimumTurnRadiusSamples,
        pursuerRange,
        captureRadius,
        numSamples,
    )


# Vectorized over multiple evaders
# mc_dubins_PEZ_heading_only = jax.jit(
#     jax.vmap(
#         mc_dubins_PEZ_heading_only_single,
#         in_axes=(
#             None,
#             None,
#             None,
#             None,
#             None,
#             None,
#             None,
#             None,
#             None,
#             None,
#             0,
#             0,
#             None,
#             None,
#         ),
#     )
# )


def plot_dubins_PEZ(
    pursuerPosition,
    pursuerPositionCov,
    pursuerHeading,
    pursuerHeadindgVar,
    pursuerSpeed,
    pursuerSpeedVar,
    minimumTurnRadius,
    minimumTurnRadiusVar,
    captureRadius,
    pursuerRange,
    pursuerRangeVar,
    evaderHeading,
    evaderSpeed,
    ax,
    fig,
):
    numPoints = 300
    rangeX = 1.5
    x = jnp.linspace(-rangeX, rangeX, numPoints)
    y = jnp.linspace(-rangeX, rangeX, numPoints)
    [X, Y] = jnp.meshgrid(x, y)
    Z = jnp.zeros_like(X)
    X = X.flatten()
    Y = Y.flatten()
    evaderHeadings = np.ones_like(X) * evaderHeading

    ZTrue = mc_dubins_PEZ(
        jnp.array([X, Y]).T,
        evaderHeadings,
        evaderSpeed,
        pursuerPosition,
        pursuerPositionCov,
        pursuerHeading,
        pursuerHeadindgVar,
        pursuerSpeed,
        pursuerSpeedVar,
        minimumTurnRadius,
        minimumTurnRadiusVar,
        pursuerRange,
        pursuerRangeVar,
        captureRadius,
    )

    ZTrue = ZTrue.reshape(numPoints, numPoints)

    X = X.reshape(numPoints, numPoints)
    Y = Y.reshape(numPoints, numPoints)
    c = ax.contour(
        X,
        Y,
        ZTrue,
        levels=[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],
    )
    fig.colorbar(c, ax=ax)
    # ax.contour(X, Y, ZGeometric, cmap="summer")
    ax.scatter(*pursuerPosition, c="r")
    ax.set_aspect("equal", "box")
    ax.set_aspect("equal", "box")
    return ax


def plot_EZ_vs_pursuer_range(
    pursuerPosition,
    pursuerHeading,
    pursuerSpeed,
    pursuerRange,
    minimumTurnRadius,
    captureRadius,
    evaderPosition,
    evaderHeading,
    evaderSpeed,
):
    fig, ax = plt.subplots()
    pursuerSpeed = np.linspace(0.2, 2, 100)
    ez = in_dubins_engagement_zone(
        pursuerPosition,
        pursuerHeading,
        minimumTurnRadius,
        captureRadius,
        pursuerRange,
        pursuerSpeed,
        evaderPosition,
        evaderHeading,
        evaderSpeed,
    )
    ax.scatter(pursuerSpeed, ez)


def main():
    pursuerPosition = np.array([0, 0])
    pursuerPositionCov = np.eye(2) * 0.000001

    pursuerHeading = (0 / 4) * np.pi
    pursuerHeadingVar = 0.1

    pursuerSpeed = 2
    pursuerSpeedVar = 0.1

    pursuerRange = 1
    pursuerRangeVar = 0

    minimumTurnRadius = 0.2
    minimumTurnRadiusVar = 0.0

    captureRadius = 0.0

    evaderHeading = jnp.array([(0 / 20) * np.pi, (0 / 20) * np.pi])
    # evaderHeading = (20 / 20) * np.pi
    evaderSpeed = 0.5
    evaderPosition = np.array([[-0.5, -0.5], [-0.5, 0.5]])

    # plot_EZ_vs_pursuer_range(
    #     pursuerPosition,
    #     pursuerHeading,
    #     pursuerSpeed,
    #     pursuerRange,
    #     minimumTurnRadius,
    #     captureRadius,
    #     evaderPosition,
    #     evaderHeading,
    #     evaderSpeed,
    # )

    ZTrue, goalPositions, ez, pursuerHeading = mc_dubins_PEZ(
        evaderPosition,
        evaderHeading,
        evaderSpeed,
        pursuerPosition,
        pursuerPositionCov,
        pursuerHeading,
        pursuerHeadingVar,
        pursuerSpeed,
        pursuerSpeedVar,
        minimumTurnRadius,
        minimumTurnRadiusVar,
        pursuerRange,
        pursuerRangeVar,
        captureRadius,
    )
    print("goalPositions", goalPositions[0])
    print("goalPositions", goalPositions[1])
    print(goalPositions[0] == goalPositions[1])
    print("ez", np.sum(ez[0] < 0))
    print("ez", np.sum(ez[1] < 0))
    fig, ax = plt.subplots()
    plt.hist(pursuerHeading[0])
    # inEZ = dubinsEZ.in_dubins_engagement_zone_single(
    #     pursuerPosition,
    #     pursuerHeading,
    #     minimumTurnRadius,
    #     captureRadius,
    #     pursuerRange,
    #     pursuerSpeed,
    #     evaderPosition[0],
    #     evaderHeading[0],
    #     evaderSpeed,
    # )
    # print(inEZ)
    # inEZ = dubinsEZ.in_dubins_engagement_zone_single(
    #     pursuerPosition,
    #     pursuerHeading,
    #     minimumTurnRadius,
    #     captureRadius,
    #     pursuerRange,
    #     pursuerSpeed,
    #     evaderPosition[1],
    #     evaderHeading[1],
    #     evaderSpeed,
    # )
    # print(inEZ)
    # fig, ax = plt.subplots()
    # plot_dubins_PEZ(
    #     pursuerPosition,
    #     pursuerPositionCov,
    #     pursuerHeading,
    #     pursuerHeadingVar,
    #     pursuerSpeed,
    #     pursuerSpeedVar,
    #     minimumTurnRadius,
    #     minimumTurnRadiusVar,
    #     captureRadius,
    #     pursuerRange,
    #     pursuerRangeVar,
    #     evaderHeading,
    #     evaderSpeed,
    #     ax,
    #     fig,
    # )
    plt.show()


if __name__ == "__main__":
    main()
